SPRING SECURITY 
it uses PasswordEncoder(I) to store and password
DelegatingPasswordEncoder is newly added to spring security

sample password generated by spring security password encoder
{bcrypt}$2a$10$.3qiRP5dTr3H6bflxkCPDey5KpNWRILbRArf5pStHQ2PYC85O15Iq

here {bcrypt} is id for used password encoder

CSRF - attack made with the help of stored sensitive cookies

Encryptors(C) provides factory methods to get following encryptors
BytesEncryptor - encrypts the text in byte[]
	Encryptors.stronger("password", "salt");
TextEncryptor
	Encryptors.text("password", "salt");
	Encryptors.queryableText("password", "salt");  this will generate same encryption result, so we can query the same in database

KeyGenerators(C) used to construct diff key generators 
	KeyGenerators.secureRandom(16);
	KeyGenerators.shared(16); same key each time

BCryptPasswordEncoder
default strangh 10, range 4-31
// Create an encoder with strength 16
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");

Pbkdf2PasswordEncoder can be used as well

we can use spring security context in JPA queries as following
select m from Message m where m.to.id = ?#{ principal?.id }

AuthenticationManager > ProviderManager > AuthenticationProvider (DaoAuthenticationProvider or JwtAuthenticationProvider)

AbstractAuthenticationProcessingFilter
diff types of authetication processing filters are used in order to create a Authentication object from request, which later is passed to AuthenticationManager 
for example UsernamePasswordAuthenticationFilter

REMEMBER ME NOTES
if user selects remember me while login, after browser closed he can still revisit 
his session based the remember me token received after login, based on a condition that the remember me token is still valid
if the token is valid for an hour, you will be remembered for an hour, you dont need to login in that hour
if you revisit session just before the remember me token expires, the session can go on even if the remember me token expired, but next time you will
have to re-login

ANONYMOUS AUTHENTICATION
by default all users are given ROLE_ANONYMOUS before they login. we can configure role anonymous to access only public URL,
this ensures tha at any given point SecurityContextHolder has a Authentication object.
For anonymous users AnonymouusAuthenticationToken is generated with ROLE_ANONYMOUS role
AnonymousAuthenticationToken [Principal=anonymousUser, Credentials=[PROTECTED], Authenticated=true, Details=WebAuthenticationDetails [RemoteIpAddress=0:0:0:0:0:0:0:1, SessionId=6F73F266856B6E4021DD7E32A90682AC], Granted Authorities=[ROLE_ANONYMOUS]]

LOGOUT HANDLERS
LogoutHandler, LogoutSuccessHandler, CookieClearingLogoutHandler and more..
we don't need to implement these handlers ourselves as we have shortcuts for the same in logout element of HttpSecurity configure method

AUTHORIZATION
AuthorizationFilter > AuthorizationManager > AuthorizationDecisionManager
AuthorizationManager reads authorities of Authentication Principal
AccessDecisionManager checks authorities before invocation(method level or request level) to decide whether to proceed further or not
we can implement AuthorizationManager to provide custom access decisions

ROLE HIERARCHY
instead of defining multiple roles to user, we can define role hierarchy, 
so that user with higher role can also access requests or methods which requires other roles(lower hierarchy roles)
for example
ROLE_ADMIN > ROLE_USER > ROLE_GUEST
so here admin can access user endpoints and user can access guest endpoints
hierarchy works downwards only

user's role and authority are the same thing only difference in how we refer them in code or database
for ex
hasRole("ADMIN") = hasAuthority("ROLE_ADMIN") in database authority will be stored as 'ROLE_ADMIN'
ROLE_ prefix is automatically added when we refer to it as role instead of authority like above, this is just for the convenience

a user can have 2 authorities in authorities table ROLE_ADMIN, CAN_DELETE_ACCOUNT
in code you can use them as follows
hasRole("ADMIN") = hasAuthority("ROLE_ADMIN")
hasAuthority("CAN_DELETE_ACCOUNT") 

you cannot use hasRole("CAN_DELETE_ACCOUNT") because ROLE_ prefix is not added in authorities table

AUTHORIZE HTTP REQUESTS
http.authorizeRequests uses FilterSecurityInterceptor while http.authorizeHttpRequests uses AuthorizationFilter(recommended)
instead of http.authorizeRequests we should use http.authorizeHttpRequests for advantages like bean based support, more customization 
and delaying authentication till it's absolutely needed

Expression based access control
we provide spring expression in .access element of antMatchers or mvcMatchers to control access via expression
for example .antMatchers("/user/**").access("hasRole('admin')")
we can also combine expressions with 'and' AND 'or'

we can refer beans in expressions
@beanName.methodName(params) here method should return boolean which help deciding whether user should be allowed access or not

refering path variables
.antMatchers("/user/{userId}/**").access("@webSecurity.checkUserId(authentication,#userId)")

METHOD LEVEL SECURITY
enable global method security with following
@EnableGlobalMethodSecurity(prePostEnabled = true)

on method level we can following to make decision
@PreAuthorize("hasRole('USER')")

with # we can access method arguments as following where name is RequestParam String
@PreAuthorize("#name == 'james'")

for method level security MethodSecurityInterceptor is used
for domain object security AspectJSecurityInterceptor is used

DOMAIN OBJECT SECURITY WITH ACL
we can add security to each domain object (each row in database)

OAUTH2
CommonOAuth2Provider enum provides default properties for populer oAuth providers like Google, Facebook, Github and Okta
Spring boot autoconfigures oAuth2 with OAuth2ClientAutoConfiguration but we can override the same